/* Ryan Barker
   ECE 4420 - Knowledge Engineering
   Fall 2015, Section 1
   ID3.c

   Purpose: Library containing numerous functions for creating and
            manipulating ID3 trees from formatted input files.
 */

/* User-defined Header File. */
#include "ID3.h"

void __attribute__ ((destructor)) ID3_destruct(void);

/* Global Variable Definitions. */
int Num_Inputs = -1;
int Num_Input_Values = -1;
int Num_Output_Values = -1;
char **Inputs = NULL;
char *Output = NULL;
char **Inputs_Key = NULL;
char **Output_Key = NULL;

/* Function Name: ID3
   Input value(s): file_name, the name of the file to run ID3 on.
   Return value(s): root, the root node of the ID3 tree cooresponding to file_name.
   Purpose: Top level function that runs ID3 on input data files.
 */
ID3_node_t *ID3(char *file_name)
{
    /* Encode data table. */
    ID3_data_t *data = ID3_encode_data(file_name);

    /* Create initial root node. */
    ID3_node_t *root = ID3_create_node(data);

    /* Run ID3 on root node. */
    ID3_compute(root, data);

    /* Return user root node. */
    return root;
}

/* Function Name: ID3_tree_destruct
   Input value(s): node, the node to be freed.
   Return value(s): None.
   Purpose: Frees trees constructed by ID3.
 */
void ID3_tree_destruct(ID3_node_t *node)
{
    /* Base case. */
    if(node == NULL) return;

    /* Forward Recursion. */
    int i;
    for(i = 0; i < Num_Input_Values; ++i) 
        ID3_tree_destruct(node->children[i]);

    /* Free table. */
    for(i = 0; i < node->data->rows; ++i) 
        free(node->data->table[i]);
    free(node->data->table);
    free(node->data);

    /* Free children slots. */
    free(node->children);

    /* Free node. */
    free(node);
}

/* Function Name: ID3_row_validate
   Input value(s): node, a node in the ID3 tree.
                   row, the row of the training set being examined.
   Return value(s): TRUE if row is successfully validated.
                    FALSE if row is not validated.
   Purpose: Auxiliary function for ID3_tree_validate that validates
            trees by their training sets on a row-by-row basis.
 */
int ID3_row_validate(ID3_node_t *node, int *row)
{
    assert(node != NULL);
    if(node->type == 'O') 
        /* Output node: Verify output is the expected value. */
        return (node->name == row[Num_Inputs]) ? TRUE : FALSE;
    else 
        /* Input Node: Follow tree to next node. */
        return ID3_row_validate(node->children[row[node->name]], row);
}

/* Function Name: ID3_tree_validate
   Input value(s): root_node
   Return value(s): TRUE if successful validation.
                    FALSE if unsuccessful validation.
   Purpose: Assess validity of ID3 trees.
 */
int ID3_tree_validate(ID3_node_t *root_node)
{
    int i, valid;
    /* Training set is the table associated with the root node. */
    ID3_data_t *training_set = root_node->data;
    printf("Beginning ID3 tree validation...\n");
    for(i = 0; i < training_set->rows; ++i) {
        /* Run ID3_row_validate for each row in the training set. */
        valid = ID3_row_validate(root_node, training_set->table[i]);
        if(!valid) {
            /* Validation failed. */
            printf("-> ID3 tree validation failed.\n");
            return FALSE;
        }
    }
    /* Validation succeeded. */
    printf("-> ID3 tree validation succeeded.\n");
    return TRUE;
}

/* Function Name: ID3_print_tree
   Input value(s): node, the node to be printed.
                   num_spaces, the number of spaces to be printed in front of the node.
   Return value(s): None.
   Purpose: Recursively prints trees generated by ID3. Ignores inconclusive nodes.
 */
void ID3_print_tree(ID3_node_t *node, int num_spaces)
{
    int i, s;
    int offset = 3;
    if(Inputs == NULL || Inputs_Key == NULL || Output == NULL || Output_Key == NULL) {
        /* Error check. */
        printf("Run ID3 before calling this function.\n");
        return;
    }
    else if(node->type == 'O') {
        /* Output node. */
        for(s = 0; s < num_spaces - offset; ++s) printf(" ");
        printf("%s -> %s\n", Output, Output_Key[node->name]);
    } else {
        /* Input node. */
        for(s = 0; s < num_spaces; ++s) printf(" ");
        printf("%s\n", Inputs[node->name]);

        for(i = 0; i < Num_Input_Values; ++i) {
            if(node->children[i] != NULL) { 
                for(s = 0; s < num_spaces; ++s) printf(" ");
                printf("%s\n", Inputs_Key[i]);
                ID3_print_tree(node->children[i], num_spaces + offset);
            }
        }
    }
}

/* Function Name: ID3_destruct
   Input value(s): None.
   Return value(s): None.
   Purpose: Cleans up remaining allocations in library at program close.
 */ 
void ID3_destruct(void)
{
    int i;

    /* Free Inputs. */
    for(i = 0; i < Num_Inputs; ++i) free(Inputs[i]);
    free(Inputs);

    /* Free Output. */
    free(Output);
 
    /* Free Inputs_Keys. */
    for(i = 0; i < Num_Input_Values; ++i) free(Inputs_Key[i]);
    free(Inputs_Key);

    /* Free Output_Key. */
    for(i = 0; i < Num_Output_Values; ++i) free(Output_Key[i]);
    free(Output_Key);
}

/* Function Name: ID3_set_globals
   Input value(s): metadata, a pointer to the current file's metadata.
   Return value(s): none.
   Purpose: Used in ID3debug.c to manually set globals without calling 
            ID3_encode_data. Allows for modular testing of ID3.
 */
void ID3_set_globals(ID3_metadata_t *metadata)
{
   /* Initialize global variables for ID3 algorithm. */
   Num_Inputs = metadata->inputs;
   Num_Input_Values = metadata->input_values;
   Num_Output_Values = metadata->output_values;
   Inputs = metadata->input_names;
   Output = metadata->output_name;
   Inputs_Key = metadata->inputs_key;
   Output_Key = metadata->output_key;
}

/* Function Name: ID3_create_node
   Input value(s): data, a pointer to the data to be linked to this node.
   Return value(s): new_node, the newly created node.
   Purpose: Used to create nodes in ID3 trees.
 */
ID3_node_t *ID3_create_node(ID3_data_t *data)
{
    /* Create and initialize new node. */
    ID3_node_t *new_node = malloc(sizeof(ID3_node_t));
    new_node->name = -1;
    new_node->type = '\0';
    new_node->data = data;
    new_node->children = malloc(Num_Input_Values * sizeof(ID3_node_t *));
    int i;
    for(i = 0; i < Num_Input_Values; ++i) new_node->children[i] = NULL;

    return new_node;
}

/* Function Name: ID3_modify_node_name
   Input value(s): node, the node to be modified.
                   new_name, the identifier for the new name of the node.
   Return value(s): None.
   Purpose: Used to rename nodes in ID3 when appropriate.
 */
void ID3_modify_node_name(ID3_node_t *node, int new_name)
{
    /* Overwrite name. */
    node->name = new_name;
}

/* Function Name: ID3_link_nodes
   Input value(s): parent, the parent node.
                   child, the child node.
                   index, the index into the pointer array for the value
                   (each index represents a different value the input can
                    take).
   Return value(s): none.
   Purpose: Links two tree nodes together in ID3.
 */
void ID3_link_nodes(ID3_node_t *parent, ID3_node_t *child, int index)
{
    /* Link nodes. */
    parent->children[index] = child;
}

/* Function Name: ID3_negative_ones
   Input value(s): data_table, the table to be checked.
   Return value(s): TRUE if all data_table columns are all -1's.
                    FALSE if all data_table columns are not all -1's.
   Purpose: Checks if the maximum amount of recursion has occured in ID3.
 */
int ID3_negative_ones(ID3_data_t *data)
{
    /* Search for all -1's. */
    int i;
    for(i = 0; i < Num_Inputs; ++i)
        if(data->table[0][i] != -1) return FALSE;

    return TRUE;
}

/* Function Name: ID3_check_outputs
   Input value(s): data, a pointer to the data to be checked.
   Return value(s): TRUE if all of the data_table outputs are the same.
                    FALSE if all of the data_table outputs are not the same. 
   Purpose: Checks for ID3 base case.
 */
int ID3_check_outputs(ID3_data_t *data)
{
    /* Search for all same output. */
    int i, output = data->table[0][Num_Inputs - 1 + 1];
    /* NOTE: The output column is coincidentally the same 
       as the number of inputs in this representation. */

    for(i = 1; i < data->rows; ++i)
        if(data->table[i][Num_Inputs] != output) return FALSE;

    return TRUE;
}

/* Function Name: ID3_most_common_output
   Input value(s): data_table, the data_table to be examined.
                   rows, the number of rows in the data table to be examined.
   Return value(s): output, the most common output.
   Purpose: Returns the most common output in case max recursion occurred.
 */
int ID3_most_common_output(ID3_data_t *data)
{
    /* Search for most common output. */
    int output = data->table[0][Num_Inputs];
    int i, num_occur = 1;

    for(i = 1; i < data->rows; ++i) {
        if(output == data->table[i][Num_Inputs]) {
            num_occur++;
        } else if(num_occur == 0) {
            output = data->table[i][Num_Inputs];
            num_occur++;
        } else {
            num_occur--;
        }
    }
   
    return output;
}

/* Function Name: ID3_entropy
   Input value(s): p, the probability to find the entropy of.
   Return value(s): Entropy of p.
   Purpose: Auxilary function that runs the entropy formula on p. Used by
            ID3_average_entropies.
 */
float ID3_entropy(float p)
{
    /* Run entropy formula. */
    if(p == 0) return 0;
    return -1*p*log2f(p);
}

/* Function Name: ID3_probability
   Input value(s): data, a pointer to the data to find a probability for.
                   output_val, the value of the output to find the probability for. 
   Return value(s): result, the probability output = output_val for data.
   Purpose: Auxilary function that finds the probability of output = output_val for
            data. Used by ID3_average_entropies.
 */
float ID3_probability(ID3_data_t *data, int output_val)
{
    int i, occur = 0;
 
    /* Find occurences of output_val. */
    for(i = 0; i < data->rows; ++i)
        if(data->table[i][Num_Inputs] == output_val) occur++;

    /* Calculate probability. */
    float result = (float) occur/data->rows;
    return result;
}

/* Function Name: ID3_average_entropies
   Input value(s): data, a pointer to the data to find average entropies for.
   Return value(s): entropies, a 1xNum_Inputs vector of the number of entropies.
   Purpose: Used to find the average entropy of each input in the overall ID3 algorithm.
 */
float *ID3_average_entropies(ID3_data_t *data)
{
    /* Declare output */
    float *entropies = malloc(Num_Inputs*sizeof(float));
    float p = 0, entropy = 0;
    int i, j, k, l;
    ID3_data_t *table = NULL;

    for(i = 0; i < Num_Inputs; ++i) {
        /* Ignore -1 entries. */
        if(data->table[0][i] == -1) entropies[i] = -1;
        else {
            /* Compute entropy. */
            for(j = 0; j < Num_Input_Values; ++j) {
                /* Partition table. */
                table = ID3_partition_table(data, i, j);
            
                if(table->rows == 0) entropy = 0;
                else {
                    /* Calculate probability and entropy for each output value. */
                    for(k = 0; k < Num_Output_Values; ++k) {
                        p = ID3_probability(table, k);
                        entropy += ID3_entropy(p);
                    }
                }

                /* Calculate entropy of current partition. */
                entropies[i] += (table->rows * entropy);

                /* Free table. */
                for (l = 0; l < table->rows; ++l) free(table->table[l]);
                free(table->table);
                free(table);
            }
 
            /* Reset entropy. */
            entropy = 0;   
        }
    }

    return entropies;
}

/* Function Name: ID3_find_input
   Input value(s): entropies, a row vector of entropy values.
   Return value(s): index, the column index (equivalently, the input)
                    with minimum entropy.
   Purpose: Finds most ideal input to partition by in the overall ID3
            algorithm.
 */
int ID3_find_input(float *entropies)
{
    /* Search for minimum entropy. */
    int i, input = 0;
    float min = entropies[input];
    for(i = 1; i < Num_Inputs; ++i) {
        if(min == -1 || (entropies[i] < min && entropies[i] != -1)) {
            min = entropies[i];
            input = i;
        }
    }

    return input;
}

/* Function Name: ID3_partition_table
   Input value(s): data, a pointer to the data to be partitioned.
                   input, the input to be partitioned by.
                   input_val, the input value to partition input on.
   Return value(s): index, the column index (equivalently, the input)
                    with minimum entropy.
   Purpose: Finds most ideal input to partition by in the overall ID3
            algorithm.
 */
ID3_data_t *ID3_partition_table(ID3_data_t *data, int input, int input_val)
{
    /* Find total number of rows that meet input = input_val. */
    int i, j, k = 0, num_new_rows = 0;
    for(i = 0; i < data->rows; ++i)
        if(data->table[i][input] == input_val) num_new_rows++;

    /* Declare output: Same size as input. */
    ID3_data_t *output = malloc(sizeof(ID3_data_t));
    output->rows = num_new_rows;
    if(output->rows > 0) {
        /* Make space for a table. */
        output->table = malloc(num_new_rows*sizeof(int *)); 
        for(i = 0; i < num_new_rows; ++i)
            output->table[i] = malloc((Num_Inputs + 1)*sizeof(int));

        /* Initialize output. */
        for(i = 0; i < data->rows; ++i) {
            if(data->table[i][input] == input_val) {
                for(j = 0; j < Num_Inputs + 1; ++j) {  
                    if(j != input) output->table[k][j] = data->table[i][j];
                    else output->table[k][j] = -1; 
                }
                k++;
            }
        }
    } else {
         /* No table */
         output->table = NULL;
    }
	
    return output;
}

/* Function Name: ID3_compute
   Input value(s): node, the current node being examined.
                   data, the data table corresponding to node.
   Return value(s): None.
   Purpose: Main ID3 auxiliary function that recursively builds ID3 trees.
 */
void ID3_compute(ID3_node_t *node, ID3_data_t *data)
{    
    if(ID3_check_outputs(data)) 
    {
        /* Base case 1 (Usual): Output is whatever triggered the if statement. */
        int output = data->table[0][Num_Inputs];       		
        ID3_modify_node_name(node, output);
        node->type = 'O';
    }
    else if(ID3_negative_ones(data))
    {
        /* Base case 2 (Rare): Out of attributes but multiple outputs - Conflicting data. 
           Never want to reach this case - Practically guarantees an invalid tree. 
           Warn user. */
        printf("***** ID3 WARNING: Out of attributes but multiple outcomes exist! *****\n");

        /* Output is "best guess" - most common output value. */
        ID3_modify_node_name(node, ID3_most_common_output(data));
        node->type = 'O';
    }
    else
    {
        /* Calculate entropy of inputs. */
        float *entropies = ID3_average_entropies(data);
        ID3_data_t *table = NULL;
        ID3_node_t *new_node = NULL;

        /* Choose an input column index based on entropy. */
        int i, input = ID3_find_input(entropies);
        free(entropies);

        /* Update node name to the input being considered. */
        ID3_modify_node_name(node, input);
        node->type = 'I';
        for(i = 0; i < Num_Input_Values; ++i)
        {
            /* Create data table partitioned by input for this value. */
            table = ID3_partition_table(data, input, i);

            if(table->rows > 0) {
                /* Create a node for the new table. */           
                new_node = ID3_create_node(table);

                /* Add the node to the ID3 tree. */
                ID3_link_nodes(node, new_node, i);

                /* Recursively call the algorithm on the new node. */
                ID3_compute(new_node, table); 
            } else {
                /* Discard empty table. */
                free(table);
            }
        }
    }		
}

/* Function Name: ID3_encode_data
   Input value(s): file_name, the name of the file to encode.
   Return value(s): data, the encoded data.
   Purpose: Encodes the specified file into an ID3_data_t structure.
 */
ID3_data_t *ID3_encode_data(char *file_name)
{ 
    FILE *fptr = fopen(file_name, "r");
    assert(fptr != NULL);
    ID3_data_t *data = malloc(sizeof(ID3_data_t));
    char line[BUFF_SIZE];
    char *no_new_line = NULL;
    int i, j, line_num = 1;
    char *s = NULL;

    /* STEP 0: Free global arrays if they are occupied. */
    if(Inputs != NULL) {
        for(i = 0; i < Num_Inputs; ++i) free(Inputs[i]);
        free(Inputs);
    }

    if(Inputs_Key != NULL) {
        for(i = 0; i < Num_Input_Values; ++i) free(Inputs_Key[i]);
        free(Inputs_Key);
    }

    if(Output != NULL) free(Output);

    if(Output_Key != NULL) {
        for(i = 0; i < Num_Output_Values; ++i) free(Output_Key[i]);
        free(Output_Key);
    }

    /* STEP 1: Initialize Global Variables with metadata. */
    while(line_num <= 3) {
        fgets(line, BUFF_SIZE, fptr);
        
        if(line_num == 1) {
            /* Inputs line. */
            no_new_line = strtok(line, "\n");
            s = strtok(no_new_line, " ");
            Num_Inputs = atoi(s);
            Inputs = malloc(Num_Inputs*sizeof(char *));
            for(i = 0; i < Num_Inputs; ++i) {
                Inputs[i] = malloc(BUFF_SIZE*sizeof(char));
                s = strtok(NULL, " ");
                strcpy(Inputs[i], s); 
            }
            s = strtok(NULL, " ");
            Num_Input_Values = atoi(s);

            Inputs_Key = malloc(Num_Input_Values*sizeof(char *));
            for(i = 0; i < Num_Input_Values; ++i) {
                Inputs_Key[i] = malloc(BUFF_SIZE*sizeof(char));
                s = strtok(NULL, " ");
                strcpy(Inputs_Key[i], s);
            }
        } else if(line_num == 2) {
            /* Outputs line. */
            no_new_line = strtok(line, "\n");
            s = strtok(no_new_line, " ");
            Output = malloc(BUFF_SIZE*sizeof(char));
            strcpy(Output, s);
            s = strtok(NULL, " ");
            Num_Output_Values = atoi(s);

            Output_Key = malloc(Num_Output_Values*sizeof(char *));
            for(i = 0; i < Num_Output_Values; ++i) {
                Output_Key[i] = malloc(BUFF_SIZE*sizeof(char));
                s = strtok(NULL, " ");
                strcpy(Output_Key[i], s);
            }
        } else {
            /* Rows line */
            s = strtok(line, "\n");
            data->rows = atoi(s);
            fgets(line, BUFF_SIZE, fptr); // Eat extra line of whitespace.
        }
        line_num++;
    }

    line_num = 0;
    data->table = malloc(data->rows*sizeof(int *));
    for(i = 0; i < data->rows; ++i) data->table[i] = malloc((Num_Inputs + 1)*sizeof(int));

    /* STEP 2: Match data lines. */
    while(line_num < data->rows) {
        /* Get line. */
        fgets(line, BUFF_SIZE, fptr);
        no_new_line = strtok(line, "\n");
        s = strtok(no_new_line, " ");

        /* Encode inputs. */
        for(i = 0; i < Num_Inputs; ++i) {
            for(j = 0; j < Num_Input_Values; ++j)
                if(!strcmp(s, Inputs_Key[j])) break;
            data->table[line_num][i] = j;
            if(i != Num_Inputs - 1) s = strtok(NULL, " ");
        }

        /* Encode outputs. */
        s = strtok(NULL, " ");
        for(j = 0; j < Num_Output_Values; ++j) 
            if(!strcmp(s, Output_Key[j])) break;
        data->table[line_num][Num_Inputs] = j;

        /* Increment line_num. */
        line_num++;
    }

    fclose(fptr);
    return data;
}

/* Function Name: ID3_print_file_data
   Input value(s): file_name, the name of the file to print.
   Return value(s): none.
   Purpose: Pretty prints file data to stdout. Useful for validating ID3 trees by hand.
 */
void ID3_print_file_data(char *file_name)
{
    printf("File contents:\n");

    /* Open file.*/
    FILE *fptr = fopen(file_name, "r");
    assert(fptr != NULL);

    /* Read file. */
    int i, j, rows = 0, meta_rows = 4;
    int num_inputs = 0;
    char line[BUFF_SIZE];
    char *s;
    for(i = 1; i <= meta_rows; ++i) {
        fgets(line, BUFF_SIZE, fptr);
        if(i == 1) {
            /* Print input names. */
            printf("  ");
            s = strtok(line, " ");
            num_inputs = atoi(s);
            for(j = 0; j < num_inputs; ++j) {
                s = strtok(NULL, " ");
                printf("%s\t", s);
            }        
        } else if(i == 2) {
            /* Print output name. */
            s = strtok(line, " ");
            printf("%s\n", s);
        } else if(i == 3) {
            /* Save number of rows. */
            s = strtok(line, " ");
            rows = atoi(s);
        } 
    }

    for(i = 1; i <= rows; ++i) {
        fgets(line, BUFF_SIZE, fptr);
        printf("  ");
        s = strtok(line, "\n");
        s = strtok(s, " ");
        for(j = 0; j < num_inputs + 1; ++j) {
            /* Print data row-by-row */
            printf("%s\t", s);
            s = strtok(NULL, " ");
        }
        printf("\n");
    }

    /* Close file. */
    fclose(fptr);
}
