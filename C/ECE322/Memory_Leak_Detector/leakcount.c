/* Ryan Barker
   ECE 3220 - Operating Systems
   Spring 2015, Section 2
   leakcount.c
   
   Purpose: This file, along with its counterpart memory_shim.c, act as a very
            basic form of valgrind: The executable created by this file takes 
            another process and its corresponding inputs as command line arguments,
            uses execvpe to execute it, and reports any leaks the process makes to 
            stderr after its ends. It also reports a total leaks statistic just
            before returning.
 */

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(int argc, char **argv, char **envp) 
{
    /* Print usage error if no program specified */
    if(argc < 2) {
        fprintf(stderr, "Usage: specify program to run.\n");
        exit(1);
    } 

    /* Copy existing environment variables, add LD_PRELOAD, and
       set LD_PRELOAD to shim library */
    int num_vars = 1;
    while(envp[num_vars - 1] != NULL) num_vars++;
    num_vars--; // Subtract NULL

    char **newenv = malloc((num_vars + 2)*sizeof(char *));
    int var;

    for(var = 0; var < num_vars; ++var) newenv[var] = envp[var];    
    newenv[num_vars] = "LD_PRELOAD=./memory_shim.so";
    newenv[num_vars + 1] = NULL; 

    /* Split into two processes */
    pid_t pid = fork(); 

    /* Have child execute execvpe to become a copy of the command specified */
    if(pid == 0) {
        execvpe(argv[1], &argv[1], newenv);
        /* If past this point, execvpe has failed. Print to stderr */
        perror("execvpe failed");
    }

    /* Parent process code below this line */

    /* Wait for child to exec */
    waitpid(pid, NULL, 0);

    /* Free environment variable array */
    free(newenv);
	
    /* Open leaks.txt for reading (Generated by memory_shim.c) */
    FILE *leaks = fopen("leaks.txt", "r");

    /* Loop through, print contents to stderr, and sum total leaks */
    int num_leaks, leaked_bytes;
    int total_leaked_bytes = 0;
    for(num_leaks = 0; fscanf(leaks, "%d", &leaked_bytes) != EOF; ++num_leaks) {
        fprintf(stderr, "LEAK\t%d\n", leaked_bytes);
        total_leaked_bytes += leaked_bytes;
    }

    /* Print total leaks to stderr */
    fprintf(stderr, "TOTAL\t%d\t%d\n", num_leaks, total_leaked_bytes);

    /* Close leaks.txt */
    fclose(leaks);

    return 0;
}
